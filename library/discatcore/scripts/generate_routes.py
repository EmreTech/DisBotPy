import argparse
import contextlib
import itertools
import pathlib
import sys
import typing as t

from typing_extensions import TypedDict, NotRequired

if sys.version_info >= (3, 11):
    import tomllib
else:
    try:
        import tomli as tomllib
    except ImportError:
        raise RuntimeError("generate_routes.py requires either the tomli library or Python >=3.11")

#############
# Constants #
#############

DEFAULT_SOURCE_DIR: t.Final[str] = "data/routes"
DEFAULT_DEST_DIR: t.Final[str] = "discatcore/http/routes"
VALID_METHODS: t.Final[list[str]] = ["GET", "HEAD", "POST", "PUT", "DELETE", "PATCH"]
GENERATION_COMMENT: t.Final[
    str
] = "# this file was auto-generated by scripts/generate_routes.py"
FILE_TEMPLATE: t.Final[
    str
] = f"""# SPDX-License-Identifier: MIT

{GENERATION_COMMENT}

import typing as t

import discord_typings as dt

from .core import EndpointMixin
from ..file import BasicFile
from ..route import Route
from ...types import Unset, UnsetOr

__all__ = ("{{0}}",)

class {{0}}(EndpointMixin):
{{1}}

"""
INIT_HEADER: t.Final[
    str
] = f"""\"\"\"
discatcore.http.endpoints
~~~~~~~~~~~~~~~~~~~~~~~~~

The implementations for Discord API endpoints. These are for internal use only, use
`discatcore.http.HTTPClient` instead.
\"\"\"

{GENERATION_COMMENT}

"""


####################
# Function Creator #
####################


class FunctionArg:
    def __init__(
        self,
        name: t.Optional[str] = None,
        *,
        annotation: t.Optional[str] = None,
        default: t.Optional[str] = None,
        pos_and_kw: bool = True,
        pos_modifier: bool = False,
        kw_modifier: bool = False,
        variable_pos: bool = False,
        variable_kw: bool = False,
    ):
        self.name: t.Optional[str] = name
        self.annotation: t.Optional[str] = annotation
        self.default: t.Optional[str] = default
        self.pos_and_kw: bool = pos_and_kw
        self.pos_modifier: bool = pos_modifier
        self.kw_modifier: bool = kw_modifier
        self.variable_pos: bool = variable_pos
        self.variable_kw: bool = variable_kw

        if self.pos_modifier and self.kw_modifier:
            raise ValueError(
                f"arg {self.name} cannot be both a positional modifier and a keyword modifier!"
            )
        if self.variable_pos and self.variable_kw:
            raise ValueError(
                f"arg {self.name} cannot be both a variable positional argument and a variable keyword argument!"
            )
        if (self.pos_modifier or self.kw_modifier) and (
            self.variable_pos or self.variable_kw
        ):
            raise ValueError(
                f"arg {self.name} cannot be both a modifier and a variable argument!"
            )
        if (self.pos_modifier or self.kw_modifier) and self.name:
            raise ValueError(f"arg {self.name} cannot be a modifier and have a name!")
        elif not (self.pos_modifier or self.kw_modifier) and not self.name:
            raise ValueError(f"non-modifier args require a name!")
        if (self.pos_modifier or self.kw_modifier) and self.annotation is not None:
            raise ValueError(f"modifier args cannot have annotations!")
        
    def __str__(self) -> str:
        str_arg = ""

        if (self.variable_pos or self.variable_kw or self.pos_and_kw) and self.name:
            if self.variable_pos or self.variable_kw:
                str_arg += "*" * (self.variable_pos or self.variable_kw * 2)
            str_arg += self.name

            if self.annotation is not None:
                str_arg += f": {self.annotation}"
            if self.default is not None:
                str_arg += f" = {self.default}"
        else:
            str_arg = "*" if self.kw_modifier else "/"

        return str_arg


def indent(text: str, *, level: int = 1) -> str:
    return "    " * level + text


class FunctionCreator:
    def __init__(
        self,
        name: str,
        *,
        decorators: t.Optional[list[str]] = None,
        is_async: bool = False,
    ) -> None:
        self.name: str = name
        self.is_async: bool = is_async
        self.args: list[FunctionArg] = []
        self.return_anno: t.Optional[str] = None
        self.decorators: t.Optional[list[str]] = decorators
        self.body: list[str] = []
        self.indent_level: int = 1

    @contextlib.contextmanager
    def indent(self):
        self.indent_level += 1
        try:
            yield
        finally:
            self.indent_level -= 1

    def print(self, *args: str) -> None:
        if not args:
            self.body.append("")
        else:
            self.body.extend(
                [indent(arg, level=self.indent_level) for arg in args]
            )

    def print_block(self, lines: str) -> None:
        for line in lines.splitlines():
            self.print(line)

    def generate_source(self) -> str:
        func_str = ""
        if self.is_async:
            func_str += "async "

        str_args = ", ".join([str(arg) for arg in self.args])
        func_str += f"def {self.name}({str_args})"
        if self.return_anno is not None:
            func_str += f" -> {self.return_anno}"
        func_str += ":\n" + "\n".join(self.body)

        return func_str


###################
# Route file spec #
###################


class ParameterSpec(TypedDict):
    name: str
    type: str
    default: NotRequired[str]


class RequestParameterSpec(TypedDict):
    name: str
    value: str


class _URLDictSpec(TypedDict):
    link: str
    parameters: list[ParameterSpec]


URLSpec = t.Union[_URLDictSpec, str]


class JSONSpec(TypedDict):
    parameters: list[ParameterSpec]


class ExtrasSpec(TypedDict):
    parameters: list[ParameterSpec]
    request_parameters: list[RequestParameterSpec]
    code: NotRequired[str]


class RouteSpec(TypedDict):
    name: str
    method: str
    url: URLSpec
    json: NotRequired[JSONSpec]
    extras: NotRequired[ExtrasSpec]
    supports_reason: NotRequired[bool]
    supports_files: NotRequired[bool]


class FileSpec(TypedDict):
    name: str
    methods: list[RouteSpec]


###################
# TOML Processing #
###################


def convert_param_spec(spec: ParameterSpec):
    name = spec["name"]
    type = spec["type"]
    default = spec.get("default")

    if type.startswith("UnsetOr"):
        default = "Unset"

    return FunctionArg(name, annotation=type, default=default)


def process_params_into_dict(params: list[ParameterSpec]):
    names = [param["name"] for param in params]
    return "{" + ", ".join(f'"{name}":{name}' for name in names) + "}"


def find_query_params(link: str, url_params: list[ParameterSpec]):
    url_params_mapping = {param["name"]: param for param in url_params}
    url_params_copy = url_params.copy()
    query_params: list[ParameterSpec] = []

    for name in url_params_mapping:
        if f"{{{name}}}" not in link:
            query_params.append(url_params_mapping[name])
            url_params_copy.remove(url_params_mapping[name])

    return url_params_copy, query_params


def process_route_func(func: RouteSpec):
    name = func["name"]

    method = func["method"]
    if method not in VALID_METHODS:
        raise ValueError(f"Invalid method {method}!")

    url = func["url"]
    url_parameters: list[ParameterSpec] = []
    query_parameters: list[ParameterSpec] = []
    if isinstance(url, dict):
        url_parameters, query_parameters = find_query_params(url["link"], url["parameters"])
        url = url["link"]

    json = func.get("json")
    json_parameters: list[ParameterSpec] = []
    if isinstance(json, dict):
        json_parameters = json["parameters"]

    extras = func.get("extras")
    extra_parameters: list[ParameterSpec] = []
    extra_request_params: list[RequestParameterSpec] = []
    code: t.Optional[str] = None
    if isinstance(extras, dict):
        extra_parameters = extras["parameters"]
        extra_request_params = extras["request_parameters"]
        code = extras.get("code")

    supports_reason = func.get("supports_reason", False)
    supports_files = func.get("supports_files", False)

    func_creator = FunctionCreator(name)
    func_creator.args.append(FunctionArg("self"))

    for param in url_parameters:
        func_creator.args.append(convert_param_spec(param))

    if json_parameters or query_parameters or extra_parameters:
        func_creator.args.append(FunctionArg(kw_modifier=True))

        for param in itertools.chain(json_parameters, query_parameters, extra_parameters):
            func_creator.args.append(convert_param_spec(param))

    if supports_reason:
        func_creator.args.append(
            FunctionArg("reason", annotation="t.Optional[str]", default="None")
        )
        extra_request_params.append(RequestParameterSpec(name="reason", value="reason"))
    if supports_files:
        func_creator.args.append(
            FunctionArg("files", annotation="UnsetOr[list[BasicFile]]", default="Unset")
        )
        extra_request_params.append(RequestParameterSpec(name="files", value="files"))

    fmted_url_params = ""
    if url_parameters:
        fmted_url_params += ", " + ", ".join([f"{param['name']}={param['name']}" for param in url_parameters])

    fmted_extra_params = ""
    if json_parameters:
        fmted_extra_params += f", json_params={process_params_into_dict(json_parameters)}"
    if query_parameters:
        fmted_extra_params += f", query_params={process_params_into_dict(query_parameters)}"
    if extra_request_params:
        fmted_extra_params += ", " + ", ".join(
            f"{param['name']}={param['value']}" for param in extra_request_params
        )

    if code is not None:
        func_creator.print_block(code)
    func_creator.print(f'r = Route("{method}", "{url}"{fmted_url_params})')
    func_creator.print(f'return self.request(r{fmted_extra_params})')

    return func_creator.generate_source()


def process_toml_file(file: FileSpec) -> str:
    parsed_methods: list[str] = []
    name = file["name"]

    for method in file["methods"]:
        parsed_method = process_route_func(method)
        parsed_methods.append("\n".join([indent(line) for line in parsed_method.splitlines()]))

    return FILE_TEMPLATE.format(
        name, "\n\n".join(parsed_methods) if parsed_methods else indent("pass")
    )


######## 
# Main #
########


def is_path_legit(p: pathlib.Path) -> bool:
    return p.exists() and p.is_dir()


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        prog="generate_endpoints",
        description="A helper for DisCatCore that processes JSON files into HTTP Endpoint functions.",
    )

    parser.add_argument(
        "-s",
        "--source",
        default=DEFAULT_SOURCE_DIR,
        help="The source directory where the JSON files are located.",
    )
    parser.add_argument(
        "-d",
        "--destination",
        default=DEFAULT_DEST_DIR,
        help="The destination directory where the generated Python files will be stored.",
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Whether the generated files should be stored. This will print the file's contents to STDOUT.",
    )
    parser.add_argument(
        "--overwrite",
        action="store_true",
        default=True,
        help="Whether a file that already exists in the destination directory should be overwritten.",
    )
    parser.add_argument(
        "--init-generation",
        action="store_true",
        default=True,
        help="Whether the __init__ file should be generated.",
    )

    return parser.parse_args()


def main() -> None:
    args: argparse.Namespace = parse_args()
    src_dir: pathlib.Path = pathlib.Path(args.source)
    dest_dir: pathlib.Path = pathlib.Path(args.destination)

    if not is_path_legit(src_dir):
        raise ValueError(
            f"Source path {str(src_dir)} is not valid. Please retry with a valid path."
        )
    if not args.dry_run and not is_path_legit(dest_dir):
        raise ValueError(
            f"Destination path {str(dest_dir)} is not valid. Please retry with a valid path."
        )

    generated_filenames: list[str] = []

    for file in sorted(src_dir.glob("*.toml")):
        loaded_file = tomllib.loads(file.read_text())
        if loaded_file:
            if t.TYPE_CHECKING:
                loaded_file = t.cast(FileSpec, loaded_file)

            print("Generating file from TOML metadata", str(file) + "...")
            generated_file = process_toml_file(loaded_file)
            print("Generated file from TOML metadata", str(file) + "!")

            if args.dry_run:
                f = sys.stdout
                generated_file += "\n"
            else:
                dest_path = dest_dir / f"{file.stem}.py"

                if dest_path.exists() and not args.overwrite:
                    print(
                        "Destination file",
                        str(dest_path),
                        "already exists and overwrite is off! Skipping...",
                    )
                    continue

                if not dest_path.exists():
                    dest_path.touch()

                f = dest_path.open("w")

            f.write(generated_file)
            generated_filenames.append(file.stem)

            if not args.dry_run:
                f.close()

    if args.init_generation:
        print("Generating __init__.py...")

        init_file = INIT_HEADER
        for filename in sorted(generated_filenames):
            init_file += f"from .{filename} import *\n"

        print("Generated __init__.py!")

        if args.dry_run:
            f = sys.stdout
            init_file += "\n"
        else:
            dest_path = dest_dir / "__init__.py"

            if dest_path.exists() and not args.overwrite:
                print(
                    "__init__.py already exists and overwrite is off! Skipping...",
                )
                return

            if not dest_path.exists():
                dest_path.touch()

            f = dest_path.open("w")

        f.write(init_file)


if __name__ == "__main__":
    main()
